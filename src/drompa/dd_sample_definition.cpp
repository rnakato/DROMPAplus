/* Copyright(c) Ryuichiro Nakato <rnakato@iqb.u-tokyo.ac.jp>
 * All rights reserved.
 */
#include "dd_sample_definition.hpp"
#include "dd_readfile.hpp"
#include "significancetest.hpp"
#include "dd_draw_myfunc.hpp"
#include "version.hpp"

namespace {

  int32_t getNcolReadNum(std::string &lineStr)
  {
    int32_t ncol_readnum(0);
    std::vector<std::string> v;
    ParseLine(v, lineStr, '\t');
    for (size_t i=0; i<v.size(); ++i) {
      if (isStr(v[i], "normalized read number")) {
        ncol_readnum = i;
        break;
      }
    }
    return ncol_readnum;
  }

  void OutputStatsfileForOtherData(const std::string &filename,
                                   const std::string &statsfile,
                                   const std::vector<chrsize> &gt,
                                   const std::unordered_map<std::string, int32_t> &totalreadnum_chr,
                                   int32_t totalreadnum)
  {
    std::cout << statsfile << " not found. Generating...";
    std::ofstream out(statsfile);

    out << "Generated by drompa+ version " << VERSION << std::endl;
    out << "Input file: \"" << filename << "\"" << std::endl;

    // Global stats
    out << "\ttotal reads\tread depth" << std::endl;

    int32_t flen(150); // Predefined fragment length
    uint64_t lengenome(0);
    for (auto &x: gt) lengenome += x.getlen();

    out << "Genome\t"
        << totalreadnum << "\t"
        << getratio(totalreadnum * flen, lengenome)
        << std::endl;
    for (auto &chr: gt) {
      out << chr.getrefname() << "\t"
          << totalreadnum_chr.at(chr.getname()) << "\t"
          << getratio(totalreadnum_chr.at(chr.getname()) * flen, chr.getlen())
          << std::endl;
    }

    std::cout << "done." << std::endl;
  }

}

SampleInfo::SampleInfo(const std::string &filename,
                       const std::vector<chrsize> &gt,
                       const int32_t _binsize,
                       const WigType &type):
  binsize(0), totalreadnum(0), prefix("")
{

  std::vector<std::string> v;
  ParseLine(v, filename, '.');
  int32_t last(v.size()-1);

  if (type != WigType::NONE) iftype = type;
  else {
    if (v[last] == "wig" || v[last] == "wiggle") iftype = WigType::UNCOMPRESSWIG;
    else if (v[last] == "gz" && (v[last-1] == "wig" || v[last-1] == "wiggle")) {
      iftype = WigType::COMPRESSWIG;
      --last;
    } else if (v[last] == "bedGraph" || v[last] == "BedGraph" || v[last] == "bedgraph") iftype = WigType::BEDGRAPH;
    else if (v[last] == "bw" || v[last] == "bigwig" || v[last] == "bigWig"|| v[last] == "BigWig") iftype = WigType::BIGWIG;
    else PRINTERR_AND_EXIT("invalid postfix: " << filename);
  }
  setbinsize(v[last-1], _binsize);
  for (int32_t i=0; i<last; ++i) prefix += v[i] + ".";
  gettotalreadnum(filename, gt);
}

void SampleInfo::setbinsize(std::string &v, const int32_t b)
{
  if (b>0) binsize = b;
  else {
    try {
      binsize = stoi(v);
    } catch (...) {
      binsize = 0;
    }
  }
  if (binsize <= 0) PRINTERR_AND_EXIT("invalid binsize: " << v);
}


void SampleInfo::scanStatsFile(const std::string &filename)
{
  DEBUGprint_FUNCStart();

  enum {NONE, PARSE2WIG, OTHER, OTHER_CHR};
  std::string lineStr;
  int32_t status(NONE);
  int32_t ncol_readnum(0);

  std::ifstream in(filename);
  if (!in) PRINTERR_AND_EXIT("cannot open " << filename);
  while (!in.eof()) {
    getline(in, lineStr);
    if(lineStr.empty() || isStr(lineStr, "% genome")) continue;

    std::vector<std::string> v;

    switch (status) {
    case NONE:
      if (isStr(lineStr, "normalized read number")) ncol_readnum = getNcolReadNum(lineStr);
      else if (isStr(lineStr, "Generated by drompa+")) {
        status = OTHER;
      } else if (isStr(lineStr, "Genome")) {
        std::vector<std::string> v;
        ParseLine(v, lineStr, '\t');
        totalreadnum = stoi(v[ncol_readnum]);
        status = PARSE2WIG;
      }
      break;
    case PARSE2WIG:
      ParseLine(v, lineStr, '\t');
      totalreadnum_chr[v[0]] = stoi(v[ncol_readnum]);
      break;
    case OTHER:
      if (isStr(lineStr, "Input file:") || isStr(lineStr, "total reads")) break;
      if (isStr(lineStr, "Genome")) {
        ParseLine(v, lineStr, '\t');
        totalreadnum = stoi(v[1]);
        status = OTHER_CHR;
      }
      break;
    case OTHER_CHR:
      ParseLine(v, lineStr, '\t');
      totalreadnum_chr[rmchr(v[0])] = stoi(v[1]);
      break;
    }
  }

  DEBUGprint_FUNCend();
}

void SampleInfo::gettotalreadnum(const std::string &filename, const std::vector<chrsize> &gt)
{
  std::string statsfile(prefix + "tsv");
  if (checkFile(statsfile)) scanStatsFile(statsfile);
  else {
    DEBUGprint("loadWigData: noStatsFile...");
    for (auto &chr: gt) {
      WigArray array(loadWigData(filename, *this, chr));
      totalreadnum_chr[chr.getname()] = array.getArraySum();
      totalreadnum += totalreadnum_chr[chr.getname()];
    }
    OutputStatsfileForOtherData(filename, statsfile, gt, totalreadnum_chr, totalreadnum);
  }

#ifdef DEBUG
    std::cout << "Total read number:" << std::endl;
    std::cout << "Whole genome: " << totalreadnum << std::endl;
    for (auto &chr: gt) {
      std::cout << chr.getname() << ": " << totalreadnum_chr[chr.getname()] << std::endl;
    }
#endif
}

void vSampleInfo::addSampleInfo(const std::string &str,
                                const std::vector<chrsize> &gt,
                                const WigType iftype)
{
  int32_t binsize(0);
  std::vector<std::string> v;
  ParseLine(v, str, ',');

  if (v.size() >8) {
    PRINTERR_AND_EXIT("error: sample std::string has ',' more than 8: " << str);
  }
  if (v[0] == "") {
    PRINTERR_AND_EXIT("please specify ChIP sample: " << str);
  }
  isFile(v[0]);

  if (v.size() >4 && v[4] != "") {
    try { binsize = stoi(v[4]); }
    catch (...) {
      std::cerr << "Warning: invalid binsize " << v[4] << "." << std::endl;
    }
  }

  // ChIP sample
  if (!Exists(v[0])) vsinfo[v[0]] = SampleInfo(v[0], gt, binsize, iftype);
  if (vsinfo[v[0]].getbinsize() <= 0) PRINTERR_AND_EXIT("please specify binsize.\n");

  // Input sample
  if (v.size() >=2 && v[1] != "") {
    if(!Exists(v[1])) vsinfo[v[1]] = SampleInfo(v[1], gt, binsize, iftype);
    if(vsinfo[v[0]].getbinsize() != vsinfo[v[1]].getbinsize()) PRINTERR_AND_EXIT("binsize of ChIP and Input should be same. " << str);
  }
}


SamplePairEach::SamplePairEach(const std::string &str, const vSampleInfo &vsinfo):
  binsize(0),
  argvChIP(""), argvInput(""), peak_argv(""), label(""), ratio(1)
{
  std::vector<std::string> v;
  ParseLine(v, str, ',');

  /* 1:ChIP   2:Input   3:label   4:peaklist   5:binsize
     6:scale_tag   7:scale_ratio   8:scale_pvalue */
  if (v[0] != "") argvChIP = v[0];
  if (v.size() >=2 && v[1] != "") argvInput = v[1];
  if (v.size() >=3 && v[2] != "") label     = v[2]; else label = basename(v[0]);
  if (v.size() >=4 && v[3] != "") peak_argv = v[3];
  if (peak_argv != "") vbedregions = parseBed_Hash<bed>(peak_argv);
  binsize = vsinfo.getbinsize(argvChIP);
  if (v.size() >=6 && v[5] != "") scale.tag = stod(v[5]);
  if (v.size() >=7 && v[6] != "") scale.ratio = stod(v[6]);
  if (v.size() >=8 && v[7] != "") scale.pvalue = stod(v[7]);

  //    printBed_Hash(vbedregions);
}


void SamplePairEach::setScalingFactor(const int32_t normtype,
                                      const vChrArray &vReadArray,
                                      const std::string &chrname)
{
  DEBUGprint_FUNCStart();
  if (argvInput == "") return; // ratio = 1;

  switch (normtype) {
  case 0:  // not normalize
    ratio = 1;
    break;
  case 1:  // total read for genome
    ratio = getratio(vReadArray.getArray(argvChIP).totalreadnum,
                     vReadArray.getArray(argvInput).totalreadnum);
    break;
  case 2:  // total read for each chromosome
    ratio = getratio(vReadArray.getArray(argvChIP).totalreadnum_chr.at(chrname),
                     vReadArray.getArray(argvInput).totalreadnum_chr.at(chrname));
    break;
  case 3:  // NCIS
    ratio = 1;
    break;
  }

  DEBUGprint("ChIP/Input Ratio for chr " << chrname << ": " << ratio);

  DEBUGprint_FUNCend();
}

void SamplePairEach::genEnrichWig(const vChrArray &vReadArray, const std::string &chrname, const int32_t chrlen)
{
  DEBUGprint_FUNCStart();

  const WigArray &ChIParray  = vReadArray.getArray(argvChIP).array;
  const WigArray &Inputarray = vReadArray.getArray(argvInput).array;

  WigArray wigarray(ChIParray.size(), 0);

  for (size_t i=0; i<ChIParray.size(); ++i) {
    if      (ofvaluetype == 0) wigarray.setval(i, getratio(ChIParray[i], (double)Inputarray[i]));
    else if (ofvaluetype == 1) wigarray.setval(i, getlogp_Poisson(ChIParray[i], ChIParray.getLocalAverage(i, binsize)));
    else if (ofvaluetype == 2) wigarray.setval(i, getlogp_BinomialTest(ChIParray[i], Inputarray[i], ratio));
    else {
      PRINTERR_AND_EXIT("Invalid outputvaluetype: " << ofvaluetype);
    }
  }

  bool showzero(true);
  bool isfloat(true);
  if (oftype==WigType::COMPRESSWIG || oftype==WigType::UNCOMPRESSWIG) {
    fprintf(File, "variableStep\tchrom=%s\tspan=%d\n", chrname.c_str(), binsize);
    wigarray.outputAsWig(File, binsize, showzero, isfloat);
  } else if (oftype==WigType::BEDGRAPH || oftype==WigType::BIGWIG) {
    wigarray.outputAsBedGraph(File, binsize, chrname, chrlen-1, showzero, isfloat);
  }

  DEBUGprint_FUNCend();
}

void SamplePairEach::peakcall_withInput(const vChrArray &vReadArray, const std::string &chrname,
                                        const double pthre_inter, const double pthre_enrich,
                                        const double ethre, const double ipm)
{
  int32_t ext(0);

  const WigArray &ChIParray  = vReadArray.getArray(argvChIP).array;
  const WigArray &Inputarray = vReadArray.getArray(argvInput).array;

  for (size_t i=0; i<ChIParray.size(); ++i) {
    double logp_inter(getlogp_Poisson(ChIParray[i], ChIParray.getLocalAverage(i, binsize)));
    double logp_enrich(getlogp_BinomialTest(ChIParray[i], Inputarray[i], ratio));
    double ratio_i(CalcRatio(ChIParray[i], Inputarray[i], ratio));

    if (!ext) {
      if (logp_inter >= pthre_inter
          && logp_enrich >= pthre_enrich
          && ratio_i >= ethre
          && ChIParray[i] >= ipm)
        {
          vPeak[chrname].emplace_back(Peak(chrname, binsize, i*binsize, (i+1)*binsize -1, ChIParray[i], logp_inter, Inputarray[i], logp_enrich));
          ext=1;
        }
    } else {
      if (logp_inter >= pthre_inter
          && logp_enrich >= pthre_enrich
          && ratio_i >= ethre
          && ChIParray[i] >= ipm)
        {
          vPeak[chrname][vPeak[chrname].size()-1].renew((i+1)*binsize -1, ChIParray[i], logp_inter, Inputarray[i], logp_enrich);
        }
      else ext=0;
    }
  }

  return;
}

void SamplePairEach::peakcall_onlyChIP(const vChrArray &vReadArray, const std::string &chrname,
                                       const double pthre_inter, const double ipm)
{
  int32_t ext(0);

  const WigArray &ChIParray = vReadArray.getArray(argvChIP).array;

  for (size_t i=0; i<ChIParray.size(); ++i) {
    double val(ChIParray[i]);
    double logp_inter(getlogp_Poisson(val, ChIParray.getLocalAverage(i, binsize)));

    if (!ext) {
      if (logp_inter >= pthre_inter && ChIParray[i] >= ipm) {
        vPeak[chrname].emplace_back(Peak(chrname, binsize, i*binsize, (i+1)*binsize -1, val, logp_inter));
        ext=1;
      }
    } else {
      if (logp_inter >= pthre_inter && ChIParray[i] >= ipm) vPeak[chrname][vPeak[chrname].size()-1].renew((i+1)*binsize -1, val, logp_inter);
      else ext=0;
    }
  }
  return;
}

void SamplePairEach::print() const
{
  std::cout << boost::format("ChIP: %1% label: %2% peaklist: %3%\n") % argvChIP % label % peak_argv;
  std::cout << boost::format("   Input: %1%\n") % argvInput;
  std::cout << boost::format("   binsize: %1%\n") % binsize;
}

void SamplePairEach::genwig_openfilestream(const std::string &prefix, WigType _oftype, int32_t _ofvaluetype)
{
  oftype = _oftype;
  ofvaluetype = _ofvaluetype;

  if (ofvaluetype == 0)      genwig_filename = prefix + "." + label + ".enrich."  + std::to_string(binsize);
  else if (ofvaluetype == 1) genwig_filename = prefix + "." + label + ".pinter."  + std::to_string(binsize);
  else if (ofvaluetype == 2) genwig_filename = prefix + "." + label + ".penrich." + std::to_string(binsize);

  if (oftype==WigType::COMPRESSWIG || oftype==WigType::UNCOMPRESSWIG) {
    genwig_filename += ".wig";
    File = fopen(genwig_filename.c_str(), "w");
    fprintf(File, "track type=wiggle_0\tname=\"%s\"\tdescription=\"Merged tag counts for every %d bp\"\n",
            genwig_filename.c_str(), binsize);
  } else if (oftype==WigType::BEDGRAPH) {
    genwig_filename += ".bedGraph";
    File = fopen(genwig_filename.c_str(), "w");

  } else if (oftype==WigType::BIGWIG) {
    genwig_filename += ".bw";
    int32_t fd(0);
    char tmpfile[] = "/tmp/drompa+_bedGraph_XXXXXX";
    if ((fd = mkstemp(tmpfile)) < 0){
      perror("mkstemp");
    }
    File = fopen(tmpfile, "w");
    genwig_tmpfile = std::string(tmpfile);
  } else {
    PRINTERR_AND_EXIT("Invalid genwig_oftype.");
  }

  std::cout << "Output filename: " << genwig_filename << std::endl;
  return;
}

void SamplePairEach::sort_bedGraph(const std::string &filename)
{
  printf("sort bedGraph...\n");
  std::string tempfile = filename + ".tmpfile";
  std::string command = "mv " + filename + " " + tempfile;
  if (system(command.c_str())) PRINTERR_AND_EXIT("mv " + filename + " " + tempfile + " failed.");

  std::ofstream out(filename);
  //      out << boost::format("browser position %1%:%2%-%3%\n") % p.genome.chr[1].getrefname() % 0 % (p.genome.chr[1].getlen()/100);
  out << "browser hide all" << std::endl;
  out << "browser pack refGene encodeRegions" << std::endl;
  out << "browser full altGraph" << std::endl;
  out << boost::format("track type=bedGraph name=\"%1%\" description=\"Merged tag counts for every %2% bp\" visibility=full\n")
    % genwig_filename % binsize;
  out.close();

  command = "sort -k1,1 -k2,2n " + tempfile + " >> " + filename;
  if (system(command.c_str())) PRINTERR_AND_EXIT("sorting bedGraph failed.");
  remove(tempfile.c_str());
}

void SamplePairEach::genwig_closefilestream(const std::string &genometablefilename)
{
  if (oftype==WigType::COMPRESSWIG || oftype==WigType::UNCOMPRESSWIG) {
    fclose(File);
    if (oftype==WigType::COMPRESSWIG) {
      std::string command = "gzip -f " + genwig_filename;
      if (system(command.c_str())) PRINTERR_AND_EXIT("gzip .wig failed.");
    }
  } else if (oftype==WigType::BEDGRAPH) {
    fclose(File);
    sort_bedGraph(genwig_filename);

  } else if (oftype==WigType::BIGWIG) {
    fclose(File);
    sort_bedGraph(genwig_tmpfile);

    std::string command = "bedGraphToBigWig " + genwig_tmpfile + " " + genometablefilename + " " + genwig_filename;
    if (system(command.c_str())) {
      unlink(genwig_tmpfile.c_str());
      std::cerr << "Error: command " << command << "return nonzero status. "
                << "Add the PATH to 'DROMPAplus/otherbins'." << std::endl;
    }
    unlink(genwig_tmpfile.c_str());
  }
}
